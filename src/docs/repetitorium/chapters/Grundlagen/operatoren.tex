\section{Operatoren}

\subsection{Operatorrangfolge}
Operatoren und deren Rangfolge sind in Tabelle~\ref{tab:javaoperators} aufgeführt.\\
Tauchen mehrere Operatoren in einer Zeile auf, gilt: Die Auswertung der Operatoren findet von links nach rechts statt, es sei denn, es handelt sich um Zuweisungsoperatoren, die von rechts nach links ausgewertet werden.

{\renewcommand{\arraystretch}{1.5}%
\setlength{\tabcolsep}{12pt}%
    \begin{table}[h]
        \centering
        \begin{tabular}{|l| c| l|}
            \hline
            \textbf{Kategorie}   & \textbf{Rang}     & \textbf{Operatoren}                                                                                         \\ \hline
            Postfix              & 1    & \code{expr++}, \code{expr-}\code{-}                                                                               \\ \hline
            Unary                & 2    & \code{++expr}, \code{-}\code{-expr}, \code{+expr}, \code{-expr}, \code{~}, \code{!}                               \\ \hline
            Multiplicative       & 3    & \code{*}, \code{/}, \code{%}                                                                              \\ \hline
            Additive             & 4    & \code{+}, \code{-}                                                                                         \\ \hline
            Shift                & 5    & \code{<}\code{<}, \code{>}\code{>}, \code{>}\code{>}\code{>}                                                                           \\ \hline
            Relational           & 6    & \code{<}, \code{>}, \code{<=}, \code{>=}, \code{instanceof}                                                \\ \hline
            Equality             & 7    & \code{==}, \code{!=}                                                                                       \\ \hline
            Bitwise AND          & 8    & \code{&}                                                                                                  \\ \hline
            Bitwise exclusive OR & 9    & \code{^}                                                                                                  \\ \hline
            Bitwise inclusive OR & 10    & \code{|}                                                                                                   \\ \hline
            Logical AND          & 11   & \code{&&}                                                                                                \\ \hline
            Logical OR           & 12    & \code{||}                                                                                                  \\ \hline
            Ternary              & 13    & \code{? :}                                                                                                 \\ \hline
            Assignment           & 14    & \code{=}, \code{+=}, \code{-=}, \code{*=}, \code{/=}, \code{%=}, \code{&=}, \code{^=}, \code{|=}, \code{<}\code{<=}, \code{>}\code{>=}, \code{>}\code{>}\code{>=} \\ \hline
        \end{tabular}
        \caption{Operatorrangfolge in Java. $1$ entspricht dem höchsten Rang bei der Evaluierung, $14$ dem niedrigsten. (Quelle: in Anlehnung an ``The Java Tutorials - Operators``:
            \url{https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html} - abgerufen 11.03.2024
         )}
        \label{tab:javaoperators}
    \end{table}}

\subsection*{Anmerkung zum Postfix-Operator}
Der durch den Postfix-Operator berechnete Wert ($+1$ / $-1$) steht erst nach Auswertung des Ausdrucks, in dem der Operator verwendet wurde, in der Variable zur Verfügung, wie folgendes Beispiel zeigt:

\begin{minted}{java}
    int n = 5;
    System.out.println(n++ - 1); // "4"
    System.out.println(n); // "6"
\end{minted}


\subsection{Kurzschluss-Operatoren}
Die mit den logischen Operatoren \code{&&} sowie \code{||} verwendeten Ausdrücke werden nur komplett ausgewertet, falls

\begin{itemize}
    \item \code{&&}: Der linke Ausdruck \code{true} ergibt
    \item \code{||}: Der linke Ausdruck \code{false} ergibt
\end{itemize}\\

\noindent
Das Prinzip lässt sich auf den \textbf{ternären Operator} \code{?:} übertragen\footnote{
s. ``15.7.2. Evaluate Operands before Operation``: \url{https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.7.2} - abgerufen 11.03.2024
}.


\subsection{Verbundoperatoren und implizite Typumwandlung}

Werden Verbundoperationen bei Datentypen genutzt, bei denen ein größerer Datentyp einem kleinere zugewisen wird, findet ein implizites Casting statt.\\

\noindent
So muss bspw. für folgende Zuweisung \textit{explizit} gecasted werden:

\begin{minted}{java}
    int i = 32;
    i = (int)50.0;
\end{minted}\\

während in folgendem Beispiel implizit gecasted wird:

\begin{minted}{java}
    int i = 32;
    i += 50.0;
\end{minted}\\
