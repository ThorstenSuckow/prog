\section{Selection-Sort}

\textbf{Selection-Sort} (\textit{Sortieren durch Auswahl}) ist ein auf Schlüsselvergleichen basierendes, \textbf{internes}, \textbf{nicht-stabiles} Sortierverfahren, das \textbf{in place} sortiert.

\subsection{Methode}
Das Sortierverfahren vergleicht zwei Teilfolgen des zu sortierenden Feldes miteinander.\\
Hierbei ist eine Teilfolge sortiert, die andere unsortiert.
Die sortierte Teilfolge ist zunächst leer.\\
Das jeweils kleinste Element aus der unsortierten Teilfolge wird an das Ende der sortierten Teilfolge eingefügt (bzw. das größte, je nach zu sortierender Reihenfolge.\\
Das ganze wird so lange wiederholt, bis die unsortierte Teilfolge nur noch aus einem Element besteht, danach ist das Feld sortiert.


\subsection{Implementierung}

\begin{minted}{java}

    for (int i = 0; i < n - 1; i++) {
        int min = arr[i];
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        int tmp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = tmp;
    }

\end{minted}


\subsection{Laufzeit}
Die äußere Schleife wird $n - 1$-mal durchlaufen, die innere - in Abhängigkeit von $i$, jeweils $n - (i + 1)$ mal.\\
Mit

\begin{equation}
    \sum_{i=0}^{n-2} \sum_{j = i + 1}^{n - 1} 1
\end{equation}

\noindent
folgt die Laufzeitkomplexität $O(n^2)$.\\

\begin{itemize}
    \item \textbf{Anzahl der Vergleiche}: $\frac{n * ( n - 1)}{2}$
    \item \textbf{Vertauschungen}: $n$ - jedes Element höchstens ein mal\footnote{s. Skript (Teil 2) ``7.3.1 Sortieren durch direktes Auswählen``
    }
\end{itemize}

\noindent
Da in der o.a. Implementierung keine Abbruchbedingung vorliegt, gilt die Laufzeitkomplexität auch für den \textbf{best}- sowie \textbf{average}-case.

