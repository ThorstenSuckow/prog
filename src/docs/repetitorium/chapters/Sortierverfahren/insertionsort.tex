\section{Insertion-Sort}

\textbf{Insertion-Sort} ist ein auf Schlüsselvergleichen basierendes, \textbf{stabiles} Sortierverfahren, das \textbf{in place} sortiert.

\subsection{Methode}

Bei \textbf{Insertion-Sort} wird das zu sortierende Feld in zwei Teilfolgen unterteilt - eine unsortierte und eine sortierte.\\
Die sortierte Folge besteht zu Beginn nur aus einem Element\footnote{womit diese als bereits sortiert gilt}.\\
Aus der unsortierten Teilfolge werden Elemente der Reihe nach entnommen und in die sortierte Folge an der richtigen Stelle eingefügt, wodurch Schlüssel ihre Position in der sortierten Folge ggf. ändern müssen.

\subsection{Implementierung}

\begin{minted}{java}
    for (int i = 1; i < n; i++) {
        int min = arr[i];
        int j = i;
        while (j > 0 && arr[j - 1] > min) {
            arr[j] = arr[j - 1];
            j--;
        }
        arr[j] = min;
    }
\end{minted}

\subsection{Laufzeit}
Die äußere Schleife wird $n-1$ mal durchlaufen, die innere so oft, bis keine Inversion mehr festgestellt wird\footnote{
    das ist einer der wesentliche Unterschied zu Selection-Sort
}.\\
Im \textbf{worst-case} muss die innere Schleife allerdings in Abhängigkeit von $i$ jeweils $i$-mal durchlaufen werden.\\

Mit

\begin{equation}
    \sum_{i = 1}^{n-1} \sum_{j=1}^i 1
\end{equation}

folgt die Laufzeitkomplexität $O(n^2)$.\\

\begin{itemize}
    \item \textbf{Anzahl der Vergleiche und Vertauschungen}: $\frac{n * ( n - 1)}{2}$ ($O(n^2)$)
\end{itemize}


\begin{tcolorbox}[title={Lineares Laufzeitverhalten}]
    Insertion-Sort eignet  sich sehr gut für \textit{vorsortierte} Felder, wo es ein \textit{lineares Laufzeitverhalten} aufweist (vgl.~\cite[188]{CL22}).
\end{tcolorbox}


